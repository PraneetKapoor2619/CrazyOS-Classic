\chapter{\centering Introduction}
\section{Introduction}
Digital electronics and programming has become the backbone of every industry. To undermine the value of digital computers and programming skills in 21st century would be an indication of the ignorance of the person making this judgement. Therefore, it becomes highly important that all undergrad students of engineering and various other technical discipline have 
\begin{enumerate}
   \item at least a rudimentary knowledge of computer hardware, and 
   \item basic programming skills in a high level language, preferably Python 3.
\end{enumerate}
The depth of such knowledge would depend upon the profession they wish to undertake.\\
For an electrical engineer, having an understanding of underlying hardware of a computer is of utmost importance. With the mathematical training they have along with their knowledge of electronics, electrical engineers are the ones who are responsible for designing the next generation computers and programming languages. This has been true in the history of computing. ENIAC, IBM 1401, Apollo Guidance Computer (AGC), Apple II, the original IBM PC, and many other similar revolutionary computers were all designed by electrical engineers. C programming language and UNIX operating system, both of which have been the backbone of the industry for over 50 years, were developed by Ken Thompson and Dennis Ritchie, both of whom were electrical engineers. The development of Linux by Linus Torvalds was also motivated by his curiosity to understand the underlying hardware of his new i386 IBM PC \cite{torvalds2001just}. TempleOS, a 64-bit ring 0 operating system was designed from scratch by Terry Davis, an electrical engineer, in spirit of the Commodore VIC-20 he used in his youth \cite{kyrou2017art}. This makes it clear that electrical engineers also enrich the field of computer architecture and programming by their contributions. A similar case can be made for other fields like mathematics and physics. Therefore, the widely held belief that programming is for those in the field of computer science or information technology (IT) is wide off the mark.\\
Now, engineering is a practical profession. A good engineer should be able to use fundamental principles to solve problems or derive practical results. The ability to do so requires experience, which is often termed as "\textit{getting hands dirty}". It is of primary importance that an engineering student should have their hands sufficiently dirty in the profession they wish to pursue. A student interested in pursuing a career in silicon industry should have considerable experience in designing systems on an FPGA board. If he\footnote[1]{"He" should be read as "he or she" throughout the report.} has only memorized the important principles from some standard book, that student will have no value in the industry. This is similar to studying mathematics: learning theory is not enough, one needs to solve enough examples to get a \textit{feel} for the concept at hand. It is also possible that while getting their hands dirty in a field they disliked at first, they might find it likeable.\\
It were these opportunities to develop practical experience which were found to be missing from the course on Microprocessers and Microcontrollers. The course, in a span of 4 units and 45 hours, covers 8085 and 8086 microcontrollers, their support components (8259 PIC, 8289 bus arbiter, LCD, stepper motor, etc.), and 8051 microcontroller. Instead of following texts like \textit{The 8086 Family User's Manual} \cite{intel1979the}, students and teachers alike follow notes and presentations which don't talk about the practical side of various concepts like segmentation, effective address calculation and string operations, to name a few. Lab experiments consist of writing code to multiply and divide two numbers, move strings from one location to another, and control a stepper motor. Rare and costly development kits, and toy emulators like emu8086 are used in favour of professional tools like NASM and QEMU. In the end, students treat it like another boring subject with "\textit{no possible application in the future}".\\
Disgruntled by the approach taken in teaching one of his favourite subjects, one of the authors of this report (Kapoor), decided to write his own 16-bit operating system from scratch. He considered this to be fun challenge which would allow him to tinker with the hardware and understand the architecture of 8086 microprocessor and the original IBM PC. His objective at first was to develop a UNIX like operating system. However, as UNIX and its derivatives (Linux, MINIX, BSD, etc.) are complex systems and developing them would require ample amount of free time, it was decided that operating system designed would be a simple one consisting of just a primitive shell and line editor. Basic commands can be executed from shell. Students can develop the their own programs using the libraries provided by the author, assemble using NASM, create a virtual disk and run it in real mode on QEMU's emulation of i386 based IBM PC. Various unconventional decisions were made while making this operating system, some of which were:
\begin{enumerate}
\item Several standard functions like \verb|printf|, and \verb|strcmp| were written from scratch following some simple non-standard calling conventions.
\item Instead of using object files and a linker to produce the final binary of the operating system, source files are combined with each other using \verb|%include| preprocessor directive. Source files are prevented from getting included more than once by using the \verb|%ifndef %define| \verb|%endif| guard (which is also used in C) \cite{nasm2015doc}.
\item Filesystem of the operating system is extremely simple. Files are stored in contiguous sectors and are terminated with a magic number, \verb|0xaa|. If the user has not kept a track of the sectors belonging to a particular file, he will most probably overwrite a file during disk write operation. There is no concept of directories.   
\end{enumerate}
Due to such unusual design of the operating system, it was named \textit{CrazyOS} by its creator.
CrazyOS is a single-user, single-tasking real mode operating system which, along with its bootloader, is written in x86 assembly language from scratch. It features a shell and a line editor. Being just 1690 lines of code, students can use it as a sandbox to gain a practical understanding of the 8086 microprocessor and architecture of the IBM PC.

\input{ch2litsurv.tex}

\section{Objective}
The objective of this project was to develop a simple real mode operating system from scratch for educational purposes. This was objective was achieved by completing the following sub-objectives:
\begin{enumerate}
\item To develop a bootloader from scratch.
\item To develop a set of libraries containing certain standard functions found in C's \verb|stdio.h| and \verb|string.h| libraries. This would assist the user in building disk applications for the system.
\item To develop a shell which enables the user to issue basic commands to interact with system components like disks, APM, etc.
\item To develop a file system using contiguous sector allocation. The file system should be simple enough to understand, implement and use with programs like the line editor.
\item To develop a build environment which allows the user to write and build their own disk applications, and run them using the operating system.
\end{enumerate}

\section{Overview}
In the present chapter we discussed about our motivation behind developing a simple operating system. In chapter 2 we discuss the implementation of CrazyOS. We have explained the source tree of the parent and the project directory along with the library functions.\\
In Chapter 3, we have provided the results of this project. Screenshots of the operating system running on an emulator are presented to the reader. The only three known bugs in the operating system are also discussed.\\
In Chapter 4, we have given a few concluding remarks and have discussed the future scope of this project.\\
The report ends with the presentation of the references, research paper, and resume of the authors.      